% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nonstandard_eval.R
\name{nonstandard_eval}
\alias{nonstandard_eval}
\alias{sym_inputs}
\alias{call_args}
\alias{call_args_nms}
\alias{active_source_path}
\alias{exprs_ops}
\alias{fns_ops}
\alias{glue_eval}
\alias{dots}
\alias{dots_named}
\alias{formals_names}
\alias{formals2chr}
\alias{formals_default}
\alias{formals_empty}
\alias{chr_pair2call}
\alias{capture_dots}
\alias{complementar_args}
\alias{modify_args}
\alias{chr2pairlist}
\alias{get_fns_ns}
\alias{simplificar_expr}
\alias{modify_body}
\alias{merge_rscrips}
\alias{call_modify}
\alias{call_standardise}
\alias{make_function}
\alias{make_call}
\alias{do_call}
\alias{call2fn}
\alias{unenclose}
\alias{f}
\alias{with_seed}
\alias{fit_with_frm}
\alias{with_newfn}
\title{herramientas}
\usage{
sym_inputs(..., evaluated = TRUE, follow = TRUE)

call_args(call)

call_args_nms(call)

active_source_path()

exprs_ops(ops, expr1, expr2, envir = env_curr())

fns_ops(ops, f1, f2, envir = env_curr())

glue_eval(..., envir = env_curr())

dots(...)

dots_named(...)

formals_names(x)

formals2chr(x)

formals_default(fn)

formals_empty(fn)

chr_pair2call(call_chr, pairlist, default = FALSE)

capture_dots(
  envir = parent.frame(3L),
  call = match.call(definition = sys.function(sys.parent()), call =
    sys.call(sys.parent()), expand.dots = FALSE, envir = parent.frame(2L)),
  as_expr = TRUE
)

complementar_args(call = sys.call(sys.parent()), envir = parent.frame(2L))

modify_args(x, forms, removals = NULL)

chr2pairlist(x, y = NULL)

get_fns_ns(file)

simplificar_expr(x)

modify_body(expr, ...)

merge_rscrips(filepath)

call_modify(call, new_args, env = parent.frame())

call_standardise(call, env = parent.frame())

make_function(args, body, env = parent.frame())

make_call(f, ..., .args = list())

do_call(f, ..., .args = list(), .env = parent.frame())

call2fn(call, env = env_call())

make_function(args, body, env = parent.frame())

unenclose(f)

f(..., .env = parent.frame())

with_seed(
  seed,
  code,
  .kind = "default",
  .normal_kind = "default",
  .sample_kind = "default"
)

fit_with_frm(data, .f, .formulas, ..., .seeds = NULL)

with_newfn(set, reset = set, envir = parent.frame(), new = TRUE)
}
\arguments{
\item{..., .args}{Arguments to the call either in or out of a list}

\item{call}{A call}

\item{envir}{\verb{[environment]}\cr Environment of the returned function.}

\item{x}{exprecion a simplificar}

\item{file}{ubicacion del archivo. se recomienda completa}

\item{new_args}{A named list of expressions
(constants, names or calls).
Use \code{NULL} to remove arguments.}

\item{env}{The parent environment of the function, defaults to the calling
environment}

\item{args}{A named list of default arguments.  Note that if you want
arguments that don't have defaults, you'll need to use the special function}

\item{body}{A language object representing the code inside the function.
Usually this will be most easily generated with}

\item{f}{a closure}

\item{.env}{parent environment of the created function}

\item{seed}{\verb{[integer(1)]}\cr The random seed to use to evaluate the code.}

\item{code}{code to evaluate}

\item{.kind}{\verb{[character(1)]}\cr Kind of (uniform) RNG to use.}

\item{.normal_kind}{\verb{[character(1)]}\cr Kind of normal RNG to use.}

\item{.sample_kind}{\verb{[character(1)]}\cr Kind of RNG to use for sampling.}

\item{data}{A dataset used to fit the models.}

\item{.f}{A fitting function}

\item{.formulas}{A list of formulas specifying a model.}

\item{set}{\verb{[function(...)]}\cr Function used to set the state.
The function can have arbitrarily many arguments, they will be replicated
in the formals of the returned function.}

\item{reset}{\verb{[function(x)]}\cr Function used to reset the state.
The first argument can be named arbitrarily, further arguments with default
values, or a "dots" argument, are supported but not used: The function will
be called as \code{reset(old)}.}

\item{new}{\verb{[logical(1)]}\cr Replace the first argument of the \code{set} function
by \code{new}? Set to \code{FALSE} if the \code{set} function only has optional arguments.}

\item{...}{Additional arguments passed on to \code{.f}}
}
\description{
crear un pairlist desde un vector de caracteres

enlistar funciones desde un archivo .R

simplifica operaciones aritmeticas

sustituir varibles em exprecion no evaluadas

consolidar n r script en uno solo

This constructs a new function given it's three components:
list of arguments, body code and parent environment.
}
\examples{

d <- quote(c)
c <- quote(b)
b <- quote(a)
a <- 2
x <- 1
y <- quote(x)
z <- quote(y)
w <- "z"

sym_inputs(x, y, z, "z", w)

gg <- function(...) {
  sym_inputs(...)
}
gg(x, y, z, "z", w)

hh <- function(...) {
  gg(...)
}

hh(x, y, z, "z", w)

jj <- function(...) {
  hh(...)
}
jj(x, y, z, "z", w)

kk <- function(...) {
  jj(...)
}
kk(x, y, z, "z", w)


sym_inputs(d, "d")
gg(d, "d")
hh(d, "d")
jj(d, "d")
kk(d, "d")

rm(list = ls())

call <- quote(f(a, b))
str(call_args(call))

e1 <- quote(x + 1)
e2 <- quote(y + 2)

exprs_ops(ops = "+", expr1 = e1, expr2 = e2)
exprs_ops(ops = "/", expr1 = e1, expr2 = e2)

x <- runif(5, 2, 10)

glue_eval("sqrt({{x}})", envir = env_curr())

formalArgs(def = runif)

formals2chr(rnorm)

eval_expr(x + 2, envir = env_curr())

eval_parse("x + 2")

chr2pairlist(x = letters[1:3], y = runif(3))
call <- quote(mean(x, na.rm = TRUE))
call_standardise(call)

# Modify an existing argument
call_modify(call, list(na.rm = FALSE))
call_modify(call, list(x = quote(y)))

# Remove an argument
call_modify(call, list(na.rm = NULL))

# Add a new argument
call_modify(call, list(trim = 0.1))

# Add an explicit missing argument
call_modify(call, list(na.rm = quote(expr = )))
f <- function(x) x + 3
g <- make_function(alist(x = ), quote(x + 3))

# The components of the functions are identical
identical(formals(f), formals(g))
identical(body(f), body(g))
identical(environment(f), environment(g))

# But the functions are not identical because f has src code reference
identical(f, g)

attr(f, "srcref") <- NULL
# Now they are:
stopifnot(identical(f, g))
# f can either be a string, a symbol or a call
make_call("f", a = 1)
make_call(quote(f), a = 1)
make_call(quote(f()), a = 1)

#' Can supply arguments individual or in a list
make_call(quote(f), a = 1, b = 2)
make_call(quote(f), list(a = 1, b = 2))
f <- function(x) x + 3
g <- make_function(alist(x = ), quote(x + 3))

# The components of the functions are identical
identical(formals(f), formals(g))
identical(body(f), body(g))
identical(environment(f), environment(g))

# But the functions are not identical because f has src code reference
identical(f, g)

attr(f, "srcref") <- NULL
# Now they are:
stopifnot(identical(f, g))
power <- function(exp) {
  function(x) x^exp
}
square <- power(2)
cube <- power(3)

square
cube
unenclose(square)
unenclose(cube)
\dontrun{

f(x + y)
f(x + y)(1, 10)
f(x, y = 2, x + y)

f({
  y <- runif(1)
  x + y
})
}


# Same random values:
with_seed(seed = 7, code = runif(5))
with_seed(seed = 10, code = runif(5))

# Use a pseudorandom value as seed to advance the RNG and pick a different
# value for the next call:
with_seed(seed <- sample.int(.Machine$integer.max, 1L), runif(5))
with_seed(seed, runif(5))
with_seed(seed <- sample.int(.Machine$integer.max, 1L), runif(5))

# fit_with_frm() is typically used with formulas().
disp_fits <- mtcars \%>\% fit_with_frm(lm, formulas(~disp,
  additive = ~ drat + cyl,
  interaction = ~ drat * cyl,
  full = add_predictors(interaction, ~am, ~vs)
))

# The list of fitted models is named after the names of the list of
# formulas:
disp_fits$full

# Additional arguments are passed on to .f
mtcars \%>\% fit_with_frm(glm, list(am ~ disp, am ~ gear + mpg), family = binomial)

x <- runif(100,0,100)
y <- 1.5*roll_noise(x,random_percent = .01)^2

data  <- data.frame(x = x, y = y)

rm(x,y)

fit_with_boots(
  .data = data,
  .fn = nls,
  times = 10,
  lhs = y ,
  rhs =  a*x^b,
  start = list(a = 1,b = 1)
)

fit_with_boots(
  .data = mtcars,
  .fn = glm,
  times = 10,
  lhs = am,
  rhs = gear + mpg,
  family = binomial
)

getwd()

with_dir <- with_newfn(setwd)
with_dir(tempdir(), getwd())

global_stack <- list()
set_global_state <- function(state, msg = "Changing global state.") {
  global_stack <- c(list(state), global_stack)
 message(msg)
  state
}
reset_global_state <- function(state) {
  old_state <- global_stack[[1]]
  global_stack <- global_stack[-1]
  stopifnot(identical(state, old_state))
}
with_newfn(set_global_state, reset_global_state)

#' # number of significant digits to print

set_options <- function(new_options) {
   do.call(options, as_l(new_options))
}

reset_options <- function(old_options) {
   options(old_options)
}

set_locale <- function(cats) {
   cats <- as_chr(cats)
   stopifnot(is_named(cats))

   if ("LC_ALL" \%in\% names(cats)) {
      stop("Setting LC_ALL category not implemented.")
   }

   old <- vapply(names(cats), Sys.getlocale, character(1))

   mapply(Sys.setlocale, names(cats), cats)
   invisible(old)
}

with_options <- with_newfn(set_options, reset_options)
local_options <- local_newfn(set_locale, dots = TRUE)
# modify temporarily the number of significant digits to print
with_options(list(digits = 3), getOption("digits"))
with_options(list(digits = 3), print(pi))

# modify temporarily the character to be used as the decimal point
getOption("digits")
with_options(list(OutDec = ","), print(pi))

# modify temporarily multiple options
with_options(list(OutDec = ",", digits = 3), print(pi))

}
\keyword{internal}
