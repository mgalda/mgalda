% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/statisticstools.R
\name{statisticstools}
\alias{statisticstools}
\alias{expected_value}
\alias{expected_var}
\alias{composite}
\alias{integrate_numerically}
\alias{integrate_composite}
\alias{integrate_lite}
\alias{integrate_safely}
\alias{trapez_integral}
\alias{is_discrete_distribution}
\alias{tsHessian}
\alias{round_any}
\alias{normal_test}
\alias{t.test.data.frame}
\alias{rescalar}
\alias{rescalar_mid}
\alias{rescalar_max}
\alias{rescaler}
\alias{unscale}
\title{integrate}
\usage{
expected_value(
  .fn,
  .g = identity,
  lower = -Inf,
  upper = Inf,
  n = 1001,
  .tol = 100000
)

expected_var(.fn, ...)

composite(f, lower, upper, n = 10, rule)

integrate_numerically(f, lower, upper, n = 20, ...)

integrate_composite(
  .fn,
  lower,
  upper,
  n = 10,
  rule = c("midpoint", "trapezoid", "simpson", "boole", "newton_cotes"),
  output = c("total", "cumulative", "marginal"),
  point = c("l", "q"),
  coef = NULL,
  open = FALSE
)

integrate_lite(f, lower, upper, n = 20, discrete = FALSE, ...)

integrate_safely(.fn, lower, upper, n = 10001, rel.tol = 0.001, target = NULL)

trapez_integral(x, y)

is_discrete_distribution(x, ...)

tsHessian(x, fun, ...)

round_any(x, accuracy, f = round)

normal_test(x)

\method{t.test}{data.frame}(.data, group_var, test_var)

rescalar(x, to, from, ...)

rescalar_mid(x, to, from, mid, ...)

rescalar_max(x, to = c(0, 1), from = range(x, na.rm = TRUE))

rescaler(x, type = "sd", ...)

unscale(x, ...)
}
\arguments{
\item{...}{other arguments passed on to methods}

\item{x}{numeric vector of values to manipulate.}

\item{fun}{funcion a optimizar}

\item{to}{output range (numeric vector of length two)}

\item{from}{input range (numeric vector of length two).  If not given, is
calculated from the range of \code{x}}

\item{mid}{mid-point of input range}
}
\description{
conjunto de test de normalidad: normal_test
}
\examples{

expected_value( function(x)dunif(x, min = 10, max = 16))
expected_value(dnorm, .g = function(x) x^2)
expected_value(
  function(x) {
    dnorm(x, sd = 4)
  },
  .g = function(x) {
    (x - expected_value(function(x)dnorm(x, sd = 4)))^2
  }
)

expected_var(function(x) dnorm(x, sd = 4))
expected_var(function(x) dunif(x, min = 10, max = 16))
expected_var(function(x) dexp(x, rate = 2))

#composite(sin, 0, pi, n = 10, rule = midpoint)
#composite(sin, 0, pi, n = 10, rule = trapezoid)

integrate_numerically(dnorm, -1.96, 1.96)


integrate_composite(sin, 0, pi, n = 10, rule = 'midpoint')
integrate_composite(sin, 0, pi, n = 10, rule = 'trapezoid')
integrate_composite(sin, 0, pi, n = 10, rule = 'simpson')
integrate_composite(sin, 0, pi, n = 10, rule = 'boole')
integrate_composite(sin, 0, pi, n = 10, rule = 'newton_cotes',coef = c(1,6,8))

integrate_composite(sin, 0, pi, n = 10, rule = "midpoint", point = "q")
integrate_composite(sin, 0, pi, n = 10, rule = "trapezoid", point = "q")
integrate_composite(sin, 0, pi, n = 10, rule = "simpson", point = "q")
integrate_composite(sin, 0, pi, n = 10, rule = "boole", point = "q")


integrate_lite(dnorm, -1.96, 1.96)

 integrate_safely(.fn = dnorm,lower = -2,upper = 2)
integrate_safely(
  .fn = function(x) {
    ddnorm(x, mean = 1, sd = 1)
  },
  lower = 0,
  upper = 4
)
integrate_safely(
  .fn = dnorm,
  lower = -2,
  upper = 2,
  target = 1
)
integrate_safely(
  .fn = function(x) {
    ddnorm(x, mean = 1, sd = 1)
  },
  lower = 0,
  upper = 4,
  target = 1
)


trapez_integral(x = seq(-2,2,.01),y = dnorm(x = seq(-2,2,.01)))

is_discrete_distribution(sample(1:10,100,T))
is_discrete_distribution(runif(100))


x <- runif(100,1,20)
y <- sqrt(x)*2-2

data <- data.frame(x = x,y = y)

exprs <-nls2expr(.data = data,x = x,y = y)


#plot(x = y,y = eval(exprs,envir = env_curr()))

exprs <-fit_nls_curve(.data = data,x = x,y = y)

#plot(x = y,y = eval(exprs,envir = env_curr()))

obj <-fit_nonlinear(.data = data,x = x,y = y)

#plot(x = y,y = predict(obj,newdata = x))


round_any(135, 10)
round_any(135, 100)
round_any(135, 25)
round_any(135, 10, floor)
round_any(135, 100, floor)
round_any(135, 25, floor)
round_any(135, 10, ceiling)
round_any(135, 100, ceiling)
round_any(135, 25, ceiling)

round_any(Sys.time() + 1:10, 5)
round_any(Sys.time() + 1:10, 5, floor)
round_any(Sys.time(), 3600)

x <- runif(100,-20,20)
center_scale(x)
cov_alt(x = x,runif(100))
xout<-create_outliers(x = x)
d2sigmoid(x = x)
dsigmoid(x = x)
entropy(x = x[x>0])
find_near(x = x,y = runif(100,-10,10))
geo_mean(x[x>0])
gini(x)
heaviside(x)
iqrize(x)
kurtosis(x)
logdesv(x,y = x*.9)
moment(x = x,order = 2)
outlier_locs(x = xout)
precision(x)
qsr(x)
quartile_skewness(x)
rescalar_outliers(xout)
sigmoid(x)
skewness(x)


x <- mgalda::datalearn$credit$price
set.seed(7)
normal_test(x)

rescalar(1:100)
rescalar(runif(50))
rescalar(1)
rescalar_mid(1:100, mid = 50.5)
rescalar_mid(runif(50), mid = 0.5)
rescalar_mid(1)
rescalar_max(1:100)
rescalar_max(runif(50))
rescalar_max(1)
}
\keyword{internal}
\keyword{manip}
