% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nonstandard_eval_formula.R
\name{nonstandard_eval_formula}
\alias{nonstandard_eval_formula}
\alias{make_formula}
\alias{formulas}
\alias{add_predictors}
\alias{frm2fn}
\title{nonstandard_eval_formula}
\usage{
make_formula(lhs, rhs, env = parent.frame())

formulas(.response, ..., .data = NULL)

add_predictors(f, ..., fun = "+")

frm2fn(x, env = parent.frame())
}
\arguments{
\item{lhs}{lefthand side of formula}

\item{rhs}{righthand side of formula}

\item{env}{environment}

\item{.response}{A one-sided formula used as the left-hand side of
all resulting formulas.}

\item{...}{Formulas whose right-hand sides will be merged to
\code{f}.}

\item{f}{A formula.}

\item{fun}{A function name indicating how to merge the right-hand
sides.}

\item{action}{action to apply in funtion:
"expand","fixed_terms","fixed_vars",
"interaction_terms","outcome","random_terms",
"random_vars","remove_term",
"remove_var","terms","vars"}

\item{frm}{formula}
}
\description{
This merges a one- or two-sided formula \code{f} with the
right-hand sides of all formulas su pplied in dots
}
\examples{

# frm_build returns a formula from two strings and an environment
make_formula("y", "a", environment())

# frm_build uses the calling environment if none is given
make_formula("y", "a")

# frm_build returns an empty model when no terms are given
make_formula("y", character(0))

# righthand
frm_modify(action = "righthand", y ~ a + b)

# frm_expand expands a formula with implicit terms into an explicit formula
frm_modify(action = "expand", y ~ a * b)

# frm_remove_term removes the given term from the formula
frm_modify(action = "remove_term", y ~ a * b, "a")

# frm_remove_term returns empty model if all right-hand terms are deleted
frm_modify(action = "remove_term", y ~ a, "a")

# frm_remove_var is okay with terms that already dont exist
frm_modify(action = "remove_var", y ~ a, "b")

# frm_remove_var removes every term on the
# right-hand side containing the variable
frm_modify(action = "remove_var", y ~ a + a:b + c, "a")

# frm_remove_var properly handles name overlap
frm_modify(action = "remove_var", y ~ a + aa, "a")

# frm_remove_ functions return the empty model
# when all right-hand terms are deleted
frm_modify(action = "remove_term", y ~ a, "a")
frm_modify(action = "remove_var", y ~ a, "a")

# frm_outcome extracts the term from the left-hand side of the formula
frm_modify(action = "outcome", y ~ a * b)

# frm_terms extracts the term from the right-hand side of the formula
frm_modify(action = "terms", y ~ a)

# frm_terms expands the formula before extracting
frm_modify(action = "terms", y ~ a * b)

# frm_interaction_terms extracts the interactive terms from the formula
frm_modify(action = "interaction_terms", y ~ a * b)

# frm_fixed_terms only extracts non-random terms from the formula
frm_modify(action = "fixed_terms", y ~ a + (1 | group))

# frm_random_terms only extracts random terms from the formula
frm_modify(action = "random_terms", y ~ a + (1 | group))

# frm_vars extracts all variables from the right-hand side
frm_modify(action = "vars", y ~ a + a:b + b:c + (1 | group))

# frm_fixed_vars extracts only the variables used in fixed terms
frm_modify(action = "fixed_vars", y ~ a + a:b + b:c + (1 | group))

# frm_random_vars extracts only the variables used in random terms
frm_modify(action = "random_vars", y ~ a + a:b + b:c + (1 | group))

get_vars(Species ~ ., iris)
get_vars(quote(Sepal.Length * Sepal.Width), iris)


invert(quote(A > 5))
invert(quote(A >= 5))
invert(quote(A < 5))
invert(quote(A <= 5))
invert(quote(A == 5))
invert(quote(A != 5))
invert(quote(A \%in\% lettters[1:5]))
invert(quote(A \%!in\% letters[1:5]))



form <- y ~ x

is_onesided_frm(form)
is_twosided_frm(form)

# FORMULA
f <- A + B ~ C + D
frm_lhs(f)
frm_lhs(f) <- quote(E / F)
f
frm_rhs(f)
frm_rhs(f) <- quote(G + H)
op(f)
op(frm_rhs(f))
op(quote(A)) # NULL:
op_type(f)

# ONE-SIDED FORMULA
f <- ~A #
frm_lhs(f) # NULL
frm_rhs(f) # A


# EXPRESSION
e <- expression(A + B == C + D)
frm_lhs(e)
frm_rhs(e)
op(e)
op_type(e)


# CALL
c <- quote(A + B > C + D)
frm_lhs(c)
frm_lhs(c) <- quote(E)
frm_rhs(c)

op(c)
op_type(c)


split_terms(1) # 1
split_terms(quote(a)) # a
split_terms(quote(-a)) # -a
split_terms(quote(a + 1)) # a, 1
split_terms(quote(1 + a)) # 1, a
split_terms(quote(-1 + a)) # -1, a
split_terms(quote(-1 - a))

split_terms(quote(a + b + c)) # a,b,c
split_terms(quote((a + b) + 1)) # (a+b),1
split_terms(quote((a + b) + 1), recursive = TRUE) # a,b,1
split_terms(quote((a - b) + 1), recursive = TRUE) # a,-b,1
split_terms(quote(-a)) # -a

split_terms(quote(a - 1)) # a, -1
split_terms(quote(-a - 1)) # -a, -1
split_terms(quote(-(a + 1))) # -(a+1)
split_terms(quote(-(a + 1)), recursive = TRUE) # -a,-1

split_terms(quote(---a))
split_terms(quote(-(a + (b - (c + d)))), recursive = TRUE)



terms(quote(A + B))

data(iris)
x <- terms(quote(. - Species), data = iris)



toggle_sign(1:3)
toggle_sign(quote(a))
toggle_sign(quote(-a))

exp <- expression(a, -b, -(a - b))
toggle_sign(exp)



# Provide named arguments to create a named list of formulas:
data <- iris
names(data) <- c("var1", "var2", "var3", "var4", "lhs")
models <- formulas(~lhs,
  additive = ~ var1 + var2,
  all = ~.,
  interaction = ~ var1 * var2,
  .data = data
)
models

# The formulas are created sequentially, so that you can refer to
# previously created formulas:
formulas(~lhs,
  linear = ~ var1 + var2,
  hierarchical = add_predictors(linear, ~ (1 | group))
)
f <- lhs ~ rhs
add_predictors(f, ~var1, ~var2)

# Left-hand sides are ignored:
add_predictors(f, lhs1 ~ var1, lhs2 ~ var2)

# fun can also be set to a function like "*":
add_predictors(f, ~var1, ~var2, fun = "*")
}
\keyword{internal}
