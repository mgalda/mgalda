% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/datamanipulation.R
\name{datamanipulation}
\alias{datamanipulation}
\alias{where}
\alias{wherenot}
\alias{all_of}
\alias{group_summarise}
\alias{group_summarise_all}
\alias{group_summarise_at}
\alias{group_mutate}
\alias{group_mutate_all}
\alias{group_filter}
\alias{group_indx}
\alias{pull_summarise}
\alias{pull_mutate}
\alias{add_denserank}
\alias{filter_invalid}
\alias{filter_freq}
\alias{rowindex}
\alias{rename_prefix}
\alias{by_row}
\alias{select_pctloss}
\alias{filter_str}
\alias{select_str}
\alias{arrange_str}
\alias{mutate_str}
\alias{summarise_str}
\alias{group_by_str}
\alias{unite_str}
\alias{dsrb_max}
\alias{dsrb_min}
\alias{dsrb_target}
\alias{dsrb_box}
\alias{dsrb_custom}
\alias{dsrb_category}
\alias{dsrb_overall}
\alias{inputs_series}
\alias{time_bnch}
\title{herramientas}
\usage{
where(fn)

wherenot(...)

all_of(x)

group_summarise(.data, .groups, ...)

group_summarise_all(.data, .groups, ...)

group_summarise_at(.data, .groups, .vars, ...)

group_mutate(.data, .groups, ...)

group_mutate_all(.data, .groups, ...)

group_filter(.data, .groups, ...)

group_indx(.data, ...)

pull_summarise(.data, .groups, ...)

pull_mutate(.data, .name_col, ...)

add_denserank(.data, ..., .groups = NULL)

filter_invalid(.data, ..., exclude = TRUE)

filter_freq(.data, .count, .groups = NULL)

rowindex(.data, random_name = F)

rename_prefix(.data, .prefix, .cols = everything())

by_row(...)

select_pctloss(x, ..., metric, maximize = TRUE, limit = 2)

filter_str(.data, ...)

select_str(.data, ...)

arrange_str(.data, ...)

mutate_str(.data, ...)

summarise_str(.data, ...)

group_by_str(.data, ...)

unite_str(.data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)

dsrb_max(x, low, high, scale = 1, missing = NA_real_, use_data = FALSE)

dsrb_min(x, low, high, scale = 1, missing = NA_real_, use_data = FALSE)

dsrb_target(
  x,
  low,
  target,
  high,
  scale_low = 1,
  scale_high = 1,
  missing = NA_real_,
  use_data = FALSE
)

dsrb_box(x, low, high, missing = NA_real_, use_data = FALSE)

dsrb_custom(x, x_vals, desirability, missing = NA_real_)

dsrb_category(x, categories, missing = NA_real_)

dsrb_overall(..., geometric = TRUE, tolerance = 0)

inputs_series(x, ...)

time_bnch(...)
}
\description{
herramientas

inputs_series

inputs_series
}
\examples{

library(ggplot2)
library(tidyverse)


set.seed(1)
dat <- tibble(x = sort(runif(30)), y = sort(runif(30)))
dsrb_max(dat$x[1:10], 0.1, 0.75)

dat \%>\%
  mutate(d_x = dsrb_max(x, 0.1, 0.75))

set.seed(2)
tibble(z = sort(runif(100))) \%>\%
  mutate(
    no_scale = dsrb_max(z, 0.1, 0.75),
    easier   = dsrb_max(z, 0.1, 0.75, scale = 1/2)
  ) \%>\%
  ggplot(aes(x = z)) +
  geom_point(aes(y = no_scale)) +
  geom_line(aes(y = no_scale), alpha = .5) +
  geom_point(aes(y = easier), col = "blue") +
  geom_line(aes(y = easier), col = "blue", alpha = .5) +
  lims(x = 0:1, y = 0:1) +
  coord_fixed() +
  ylab("Desirability")


# Target example

dat \%>\%
  mutate(
    triangle = dsrb_target(x, 0.1, 0.5, 0.9,
    scale_low = 2, scale_high = 1/2)
  ) \%>\%
  ggplot(aes(x = x, y = triangle)) +
  geom_point() +
  geom_line(alpha = .5) +
  lims(x = 0:1, y = 0:1) +
  coord_fixed() +
  ylab("Desirability")


# Box constraints

dat \%>\%
  mutate(box = dsrb_box(x, 1/4, 3/4)) \%>\%
  ggplot(aes(x = x, y = box)) +
  geom_point() +
  geom_line(alpha = .5) +
  lims(x = 0:1, y = 0:1) +
  coord_fixed() +
  ylab("Desirability")


# Custom function

v_x <- seq(0, 1, length.out = 20)
v_d <- 1 - exp(-10 * abs(v_x - .5))

dat \%>\%
  mutate(v = dsrb_custom(x, v_x, v_d)) \%>\%
  ggplot(aes(x = x, y = v)) +
  geom_point() +
  geom_line(alpha = .5) +
  lims(x = 0:1, y = 0:1) +
  coord_fixed() +
  ylab("Desirability")


# Qualitative data

set.seed(3)
groups <- sort(runif(10))
names(groups) <- letters[1:10]

tibble(x = letters[1:7]) \%>\%
  mutate(d = dsrb_category(x, groups)) \%>\%
  ggplot(aes(x = x, y = d)) +
  geom_bar(stat = "identity") +
  lims(y = 0:1) +
  ylab("Desirability")


# Apply the same function to many columns at once (dplyr > 1.0)

dat \%>\%
  mutate(across(c(everything()), ~ dsrb_min(., .2, .6), .names = "d_{col}"))


# Choose model tuning parameters that minimize the number of predictors used
# while maximizing the area under the ROC curve.

datalearn$classification_results \%>\%
  mutate(
    d_feat = dsrb_min(num_features, 1, 200),
    d_roc  = dsrb_max(roc_auc, 0.5, 0.9),
    d_all  = dsrb_overall(across(starts_with("d_")))
  ) \%>\%
  arrange(desc(d_all))

# Bias the ranking toward minimizing features by using a larger scale.

datalearn$classification_results \%>\%
  mutate(
    d_feat = dsrb_min(num_features, 1, 200, scale = 3),
    d_roc  = dsrb_max(roc_auc, 0.5, 0.9),
    d_all  = dsrb_overall(across(starts_with("d_")))
  ) \%>\%
  arrange(desc(d_all))



library(ggplot2)
x <- runif(1000)
time_bnch(
min = f(min(x, na.rm = TRUE) > 0),
all_rm = f(all(safe_vec(x, ops = "rm") > 0)),
all_mean = f(all(safe_vec(x, ops = "mean") > 0)),
all_random =f(all(safe_vec(x, ops = "random") > 0)),x = x
)

}
\keyword{internal}
