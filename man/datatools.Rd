% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/datatools.R
\name{datatools}
\alias{datatools}
\alias{lazyquo}
\alias{rec_expr}
\alias{interp}
\alias{fn_each}
\alias{partial_fn}
\alias{env_get}
\alias{env_get_safe}
\alias{expr_get_quotable}
\alias{envs_prnts}
\alias{as.envlist}
\alias{env_prnt}
\alias{env_call}
\alias{env_file}
\alias{env_curr}
\alias{env_ns}
\alias{env_fn}
\alias{eval_quoted}
\title{Convert an object to a lazy expression or lazy dots.}
\usage{
lazyquo(x, env = env_call(), warn = FALSE)

rec_expr(expr, ...)

interp(obj_, ..., .values)

fn_each(...)

partial_fn(.fn, ..., .env = parent.frame(), .lazy = TRUE)

env_get(env, default = NULL)

env_get_safe(x, env = env_call(), lock = TRUE)

expr_get_quotable(x)

envs_prnts(e = parent.frame(), all = FALSE)

as.envlist(x)

env_prnt(env = parent.frame(), n = 1)

env_call(n = 1)

env_file(file)

env_curr()

env_ns(x = caller_env())

env_fn(x, default_env = env_prnt())

eval_quoted(exprs, envir = NULL, enclos = NULL, try = FALSE)
}
\arguments{
\item{x}{A list of environments.}

\item{env}{an environment}

\item{expr}{an expression that can be expanded to a sum}

\item{..., .values}{Either individual name-value pairs, or a list
(or environment) of values.}

\item{e}{An environment or other object.}

\item{all}{If \code{FALSE} (the default), stop at the global
environment or the empty environment. If \code{TRUE}, print all
parents, stopping only at the empty environment (which is the
top-level environment).}

\item{n}{number of parents to go up}

\item{_obj}{An object to modify: can be a call, name, formula,
\code{\link{lazy}}, or a string.}

\item{...}{functions to combine. each function should produce a single}
}
\description{
If \code{e} is not specified, it will start with environment from which
the function was called.
}
\examples{

library(rlang)
#'
env <- child_env(current_env())
lazy <-
  structure(list(expr = quote(foo(bar)), env = env), class = "lazy")
lazyquo(lazy)
lazy_str <- "foo(bar)"
lazyquo(lazy_str)
lazy_lang <- quote(foo(bar))
lazyquo(lazy_lang)
lazy_sym <- quote(foo)
lazyquo(lazy_sym)


env <- child_env(current_env())
lazy_dots <-
  structure(class = "lazy_dots", list(
    lazy = structure(list(expr = quote(foo(
      bar
    )), env = env), class = "lazy"),
    lazy_lang = quote(foo(bar))
  ))
expected <-
  list(
    lazy = new_quosure(quote(foo(bar)), env),
    lazy_lang = quo(foo(bar)),
    quo(foo(bar))
  )
lazyquos(lazy_dots, current_env(), "foo(bar)")


lazy_dots <-
  structure(class = "lazy_dots", list("foo(baz)", quote(foo(bar))))
expected <-
  list(
    `foo(baz)` = quo(foo(baz)),
    `foo(bar)` = quo(foo(bar)),
    foobarbaz = quo(foo(barbaz))
  )
dots <-
  lazyquos(lazy_dots,
    current_env(),
    foobarbaz = "foo(barbaz)",
    .named = TRUE
  )
dots


lazyquo()


lazy <-
  structure(list(expr = quote(foo), env = empty_env()), class = "lazy")
lazyquos(lazy)


lazyquos(quote(foo), empty_env())
lazyquos(quote(foo(bar)), empty_env())


lazyquos(NULL, current_env(), c("foo", "bar"))


lazyquos(NULL, current_env(), NA_real_)
lazyquos(NULL, current_env(), 1:3)


lazyquo(~foo)
lazyquos(~foo)



# lazy_dots(x = 1)
# lazy_dots(a, b, c * 4)

# f <- function(x = a + b, ...) {
#  lazy_dots(x = x, y = a + b, ...)
# }
# f(z = a + b)
lazy_dots(letters)

# You can also modify a dots like a list. Anything on the RHS will
# be coerced to a lazy.
l <- lazy_dots(x = 1)
l$y <- quote(f)
l[c("y", "x")]
l["z"] <- list(~g)
# c(lazy_dots(x = 1), lazy_dots(f))

lz_expr <- as_call("mean(x)")
lz <- as_lazy(lz_expr)
lz
x <- runif(10)
eval_lazy(expr = lz, data = list(x = x))

lz <- as_lazy(letters[1:4])
x <- letters[1:4]
eval_lazy(expr = lz, data = list(x = x))

lz <- as_lazy(~ y + x * 2)
y <- runif(min = -1, max = 2, n = 10)
x <- runif(10)
eval_lazy(expr = lz, data = list(x = x, y = y))

lz <- as_lazy(lz)
eval_lazy(expr = lz, data = list(x = x, y = y))

lz <- as_lazy(TRUE)
eval_lazy(expr = lz)

lz <- as_lazy(x)
eval_lazy(expr = lz)

lz <- as_lazy(NULL)
eval_lazy(expr = lz)

lz <- as_lazy(2)
eval_lazy(expr = lz)

lz <- quo(x + y)
lz <- as_lazy(lz)
eval_lazy(expr = lz)

lz <- .(x, y)
lz <- as_lazy(lz)
eval_lazy(expr = lz)

lazy(quote(a + x), globalenv())
f <- function(x = b - a) {
  x <- substitute(x)
  lazy(x)
}
f()
f(a + b / c)
lazy(quote(a + b / c))
g <- function(y) f(y)
h <- function(z) g(z)
f(quote(a + b))
g(quote(a + b))
h(quote(a + b))

# create a sum from x_1 to x_10
rec_expr(x[i], i = 1:10)
# create a sum from x_2 to x_10 with even indexes
rec_expr(x[i], i = 1:10, i \%\% 2 == 0)
# Interp works with formulas, lazy objects, quoted calls and strings
interp(~ x + y, x = 10)
interp(quote(x + y), x = 10)
interp("x + y", x = 10)

# Use as.name if you have a character string that gives a
# variable name
interp(~ mean(var), var = as.name("mpg"))
# or supply the quoted name directly
interp(~ mean(var), var = quote(mpg))

# Or a function!
interp(~ f(a, b), f = as.name("+"))

# If you've built up a list of values through some other
# mechanism, use .values
interp(~ x + y, .values = list(x = 10))

# You can also interpolate variables defined in the current
# environment, but this is a little risky.
y <- 10
interp(~ x + y, .values = environment())
# Call min() and max() on the vector 1:10
fn_each(min, max)(1:10)
# This syntax looks a little different.  It is shorthand for the
# the following:
f <- fn_each(min, max)
f(1:10)
# Three equivalent ways to call min() and max() on the vector 1:10
fn_each("min", "max")(1:10)
fn_each(c("min", "max"))(1:10)
fn_each(c(min, max))(1:10)
# Call length(), min() and max() on a random normal vector
fn_each(length, mean, var)(rnorm(100))

compact1 <- function(x) Filter(Negate(is.null), x)

# we can write:
compact2 <- partial_fn(Filter, Negate(is.null))

# and the generated source code is very similar to what we made by hand
compact1
compact2

# Note that the evaluation occurs "lazily" so that arguments will be
# repeatedly evaluated
f <- partial_fn(runif, n = rpois(1, 5))
f
f()
f()

# You can override this by saying .lazy = FALSE
f <- partial_fn(runif, n = rpois(1, 5), .lazy = FALSE)
f
f()
f()

# # This also means that partial works fine with functions that do
# # non-standard evaluation
# my_long_variable <- 1:10
# plot2 <- partial_fn(plot, my_long_variable)
# plot2()
# plot2(runif(10), type = "l")
# Print the current environment and its parents
envs_prnts()

# Print the parent environments of the load_all function
e <- envs_prnts(envs_prnts)
e

# Get all parent environments, going all the way to empty env
e <- envs_prnts(envs_prnts, TRUE)
e

# Print e with paths
print(e, path = TRUE)

# Print the first 6 environments in the envlist
e[1:6]

# Print just the parent environment of load_all.
# This is an envlist with one element.
e[1]

# Pull that environment out of the envlist and see what's in it.
e[[1]]
ls(e[[1]], all.names = TRUE)
adder <- function(x) function(y) x + y
add2 <- adder(2)
env_prnt(add2)
data <- rep(1:3, 10)
data <- dplyr::tibble(a = data, b = data, c = data) \%>\% dplyr::arrange(a)

expr_e <- quote(expr = kmeans(x = data, centers = k))
expr_e
k <- 3
k <- kmeans(x = data, centers = k)
k <- k$centers
data
k
res <- kmeans(x = data, centers = k)

eval_lazy(expr = as_lazy(expr_e)) \%==\% res
eval_quosures(expr = as_quosure(expr_e)) \%==\% res
eval_quosures(expr = lazyquo(expr_e)) \%==\% res
eval_parse(expr = deparse(expr_e)) \%==\% res

# eval_lazy(expr = as_lazy_dots(expr_e))
# eval_quosures(expr = as_quosures(expr_e,env = env_call()))
# eval_quosures(expr = lazyquos(expr_e,env = env_call()))


expr_e <- list(a = expr_e, b = expr_e)

res <- list(a = res, b = res)

eval_lazy(expr = as_lazy(expr_e)) \%==\% res
eval_quosures(expr = as_quosure(expr_e)) \%==\% unname(res)
eval_quosures(expr = lazyquo(expr_e)) \%==\% res
eval_parse(expr = deparse(expr_e)) \%==\% res

eval_lazy(expr = as_lazy_dots(expr_e)) \%==\% res
eval_quosures(expr = as_quosures(expr_e, env = env_call())) \%==\% res
eval_quosures(expr = lazyquos(expr_e, env = env_call())) \%==\% res

rm_ls()
a <- sample(1:5)
b <- sample(1:5)
c <- sample(1:5)

abc_env <- a + b - c
data <- dplyr::tibble(a = runif(5), b = runif(5), c = runif(5))
abc_data <- data$a + data$b - data$c
expr <- quote(a + b - c)

eval_safe(expr = as_lazy(expr)) \%==\% abc_env
eval_safe(expr = as_quosure(expr)) \%==\% abc_env
eval_safe(expr = lazyquo(expr)) \%==\% abc_env
eval_safe(expr = expr) \%==\% abc_env
eval_safe(expr = deparse(expr)) \%==\% abc_env
eval_safe(expr = as_lazy_dots(expr), follow = TRUE) \%==\% abc_env
eval_safe(expr = lazyquos(expr), follow = TRUE) \%==\% abc_env

eval_safe(expr = as_lazy(expr), envir = env_call()) \%==\% abc_env
eval_safe(expr = as_quosure(expr), envir = env_call()) \%==\% abc_env
eval_safe(expr = lazyquo(expr), envir = env_call()) \%==\% abc_env
eval_safe(expr = expr, envir = env_call()) \%==\% abc_env
eval_safe(expr = deparse(expr), envir = env_call()) \%==\% abc_env
#eval_safe(expr = as_lazy_dots(expr), envir = env_call(), follow = TRUE) \%==\% abc_env
eval_safe(expr = lazyquos(expr), envir = env_call(), follow = TRUE) \%==\% abc_env

eval_safe(expr = as_lazy(expr), data = data) \%==\% abc_data
eval_safe(expr = as_quosure(expr), data = data) \%==\% abc_data
eval_safe(expr = lazyquo(expr), data = data) \%==\% abc_data
eval_safe(expr = expr, data = data) \%==\% abc_data
eval_safe(expr = as_lazy_dots(expr), data = data, follow = TRUE) \%==\% abc_data

eval_safe(expr = as_lazy(expr), data = data, envir = env_call()) \%==\% abc_data
eval_safe(expr = as_quosure(expr), data = data, envir = env_call()) \%==\% abc_data
eval_safe(expr = lazyquo(expr), data = data, envir = env_call()) \%==\% abc_data
eval_safe(expr = expr, data = data, envir = env_call()) \%==\% abc_data
eval_safe(expr = deparse(expr), data = data, envir = env_call()) \%==\% abc_data
eval_safe(expr = as_lazy_dots(expr), data = data, envir = env_call(), follow = TRUE) \%==\% abc_data



q <- quote(c)
expr <- quote(a + b - q)



eval_safe(expr = as_lazy(expr), follow = TRUE) \%==\% abc_env
eval_safe(expr = as_quosure(expr), follow = TRUE) \%==\% abc_env
eval_safe(expr = lazyquo(expr), follow = TRUE) \%==\% abc_env
eval_safe(expr = expr, follow = TRUE) \%==\% abc_env
eval_safe(expr = deparse(expr), follow = TRUE) \%==\% abc_env
eval_safe(expr = as_lazy_dots(expr), follow = TRUE) \%==\% abc_env
eval_safe(expr = lazyquos(expr), follow = TRUE) \%==\% abc_env

eval_safe(expr = as_lazy(expr, env = env_call()), envir = env_call(), follow = TRUE) \%==\% abc_env
eval_safe(expr = as_quosure(expr), envir = env_call(), follow = TRUE) \%==\% abc_env
eval_safe(expr = lazyquo(expr), envir = env_call(), follow = TRUE) \%==\% abc_env
eval_safe(expr = expr, envir = env_call(), follow = TRUE) \%==\% abc_env
eval_safe(expr = deparse(expr), envir = env_call(), follow = TRUE) \%==\% abc_env
#eval_safe(expr = as_lazy_dots(expr), envir = env_call(), follow = TRUE) \%==\% abc_env
#eval_safe(expr = lazyquos(expr), envir = env_call(), follow = TRUE) \%==\% abc_env

eval_safe(expr = as_lazy(expr), data = data, follow = TRUE) \%==\% abc_data
eval_safe(expr = as_quosure(expr), data = data, follow = TRUE) \%==\% abc_data
eval_safe(expr = lazyquo(expr), data = data, follow = TRUE) \%==\% abc_data
eval_safe(expr = expr, data = data, follow = TRUE) \%==\% abc_data
eval_safe(expr = deparse(expr), data = data, follow = TRUE) \%==\% abc_data
#eval_safe(expr = as_lazy_dots(expr), data = data, follow = TRUE) \%==\% abc_data
#eval_safe(expr = lazyquos(expr), data = data, follow = TRUE) \%==\% abc_data

# eval_safe(
#   expr = as_lazy(expr),
#   data = data,
#   envir = env_call(),
#   follow = TRUE
# ) \%==\% abc_data
#
# eval_safe(
#   expr = as_quosure(expr),
#   data = data,
#   envir = env_call(),
#   follow = TRUE
# ) \%==\% abc_data
#
# eval_safe(
#   expr = lazyquo(expr),
#   data = data,
#   envir = env_call(),
#   follow = TRUE
# ) \%==\% abc_data
#
# eval_safe(
#   expr = expr,
#   data = data,
#   envir = env_call(),
#   follow = TRUE
# ) \%==\% abc_data
#
#
# eval_safe(
#   expr = deparse(expr),
#   data = data,
#   envir = env_call(),
#   follow = TRUE
# ) \%==\% abc_data
#
# eval_safe(
#   expr = as_lazy_dots(expr),
#   data = data,
#   envir = env_call(),
#   follow = TRUE
# ) \%==\% abc_data
#
# eval_safe(
#   expr = lazyquos(expr),
#   data = data,
#   envir = env_call(),
#   follow = TRUE
# ) \%==\% abc_data
}
\keyword{internal}
